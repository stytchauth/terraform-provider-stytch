package resources

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int32planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/stytchauth/stytch-management-go/v3/pkg/api"
	"github.com/stytchauth/stytch-management-go/v3/pkg/models/environments"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ resource.Resource                = &environmentResource{}
	_ resource.ResourceWithConfigure   = &environmentResource{}
	_ resource.ResourceWithImportState = &environmentResource{}
)

func NewEnvironmentResource() resource.Resource {
	return &environmentResource{}
}

type environmentResource struct {
	client *api.API
}

// Note: This resource only supports TEST environments for now.
type environmentResourceModel struct {
	ID                                                     types.String `tfsdk:"id"`
	ProjectSlug                                            types.String `tfsdk:"project_slug"`
	ProjectID                                              types.String `tfsdk:"project_id"`
	EnvironmentSlug                                        types.String `tfsdk:"environment_slug"`
	Name                                                   types.String `tfsdk:"name"`
	OAuthCallbackID                                        types.String `tfsdk:"oauth_callback_id"`
	CrossOrgPasswordsEnabled                               types.Bool   `tfsdk:"cross_org_passwords_enabled"`
	UserImpersonationEnabled                               types.Bool   `tfsdk:"user_impersonation_enabled"`
	ZeroDowntimeSessionMigrationURL                        types.String `tfsdk:"zero_downtime_session_migration_url"`
	UserLockSelfServeEnabled                               types.Bool   `tfsdk:"user_lock_self_serve_enabled"`
	UserLockThreshold                                      types.Int32  `tfsdk:"user_lock_threshold"`
	UserLockTTL                                            types.Int32  `tfsdk:"user_lock_ttl"`
	IDPAuthorizationURL                                    types.String `tfsdk:"idp_authorization_url"`
	IDPDynamicClientRegistrationEnabled                    types.Bool   `tfsdk:"idp_dynamic_client_registration_enabled"`
	IDPDynamicClientRegistrationAccessTokenTemplateContent types.String `tfsdk:"idp_dynamic_client_registration_access_token_template_content"`
	CreatedAt                                              types.String `tfsdk:"created_at"`
	LastUpdated                                            types.String `tfsdk:"last_updated"`
}

func (r *environmentResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*api.API)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *api.API (stytch-management-go client), got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	r.client = client
}

func (r *environmentResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_environment"
}

func (r *environmentResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages a test environment within a Stytch project. This resource only supports TEST type environments.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "A computed ID field used for Terraform resource management (format: project_slug.environment_slug).",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"project_slug": schema.StringAttribute{
				Description: "The slug of the project this environment belongs to.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"project_id": schema.StringAttribute{
				Description: "The ID of the project this environment belongs to (used for API authentication).",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"environment_slug": schema.StringAttribute{
				Description: "The immutable unique identifier for the environment. One will be generated by Stytch if not provided.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				Description: "The environment's name.",
				Required:    true,
			},
			"oauth_callback_id": schema.StringAttribute{
				Description: "The callback ID used in OAuth requests for the environment.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"cross_org_passwords_enabled": schema.BoolAttribute{
				Description: "Whether cross-org passwords are enabled for the environment. Irrelevant for Consumer projects.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"user_impersonation_enabled": schema.BoolAttribute{
				Description: "Whether user impersonation is enabled for the environment.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"zero_downtime_session_migration_url": schema.StringAttribute{
				Description: "The OIDC-compliant UserInfo endpoint for session migration.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"user_lock_self_serve_enabled": schema.BoolAttribute{
				Description: "Whether users who get locked out should automatically get an unlock email magic link.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"user_lock_threshold": schema.Int32Attribute{
				Description: "The number of failed authenticate attempts that will cause a user to be locked. Defaults to 10.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Int32{
					int32planmodifier.UseStateForUnknown(),
				},
			},
			"user_lock_ttl": schema.Int32Attribute{
				Description: "The time in seconds that a user remains locked once the lock is set. Defaults to 1 hour (3600 seconds).",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Int32{
					int32planmodifier.UseStateForUnknown(),
				},
			},
			"idp_authorization_url": schema.StringAttribute{
				Description: "The OpenID Configuration endpoint for Connected Apps for the environment.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"idp_dynamic_client_registration_enabled": schema.BoolAttribute{
				Description: "Whether the project has opted in to Dynamic Client Registration (DCR) for Connected Apps.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"idp_dynamic_client_registration_access_token_template_content": schema.StringAttribute{
				Description: "The access token template to use for clients created through Dynamic Client Registration (DCR).",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"created_at": schema.StringAttribute{
				Description: "The ISO-8601 timestamp when the environment was created.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"last_updated": schema.StringAttribute{
				Description: "Timestamp of the last Terraform update.",
				Computed:    true,
			},
		},
	}
}

func (r *environmentResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan environmentResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx = tflog.SetField(ctx, "project_slug", plan.ProjectSlug.ValueString())
	ctx = tflog.SetField(ctx, "project_id", plan.ProjectID.ValueString())
	ctx = tflog.SetField(ctx, "environment_slug", plan.EnvironmentSlug.ValueString())
	ctx = tflog.SetField(ctx, "environment_name", plan.Name.ValueString())
	tflog.Info(ctx, "Creating test environment")

	// Create the environment with TEST type
	createReq := environments.CreateRequest{
		ProjectSlug: plan.ProjectSlug.ValueString(),
		Name:        plan.Name.ValueString(),
		Type:        environments.EnvironmentTypeTest,
	}
	envSlug := plan.EnvironmentSlug.ValueString()
	createReq.EnvironmentSlug = &envSlug

	if !plan.CrossOrgPasswordsEnabled.IsNull() && !plan.CrossOrgPasswordsEnabled.IsUnknown() {
		createReq.CrossOrgPasswordsEnabled = ptr(plan.CrossOrgPasswordsEnabled.ValueBool())
	}
	if !plan.UserImpersonationEnabled.IsNull() && !plan.UserImpersonationEnabled.IsUnknown() {
		createReq.UserImpersonationEnabled = ptr(plan.UserImpersonationEnabled.ValueBool())
	}
	if !plan.ZeroDowntimeSessionMigrationURL.IsNull() && !plan.ZeroDowntimeSessionMigrationURL.IsUnknown() {
		createReq.ZeroDowntimeSessionMigrationURL = ptr(plan.ZeroDowntimeSessionMigrationURL.ValueString())
	}
	if !plan.UserLockSelfServeEnabled.IsNull() && !plan.UserLockSelfServeEnabled.IsUnknown() {
		createReq.UserLockSelfServeEnabled = ptr(plan.UserLockSelfServeEnabled.ValueBool())
	}
	if !plan.UserLockThreshold.IsNull() && !plan.UserLockThreshold.IsUnknown() {
		createReq.UserLockThreshold = ptr(int(plan.UserLockThreshold.ValueInt32()))
	}
	if !plan.UserLockTTL.IsNull() && !plan.UserLockTTL.IsUnknown() {
		createReq.UserLockTTL = ptr(int(plan.UserLockTTL.ValueInt32()))
	}
	if !plan.IDPAuthorizationURL.IsNull() && !plan.IDPAuthorizationURL.IsUnknown() {
		createReq.IDPAuthorizationURL = ptr(plan.IDPAuthorizationURL.ValueString())
	}
	if !plan.IDPDynamicClientRegistrationEnabled.IsNull() && !plan.IDPDynamicClientRegistrationEnabled.IsUnknown() {
		createReq.IDPDynamicClientRegistrationEnabled = ptr(plan.IDPDynamicClientRegistrationEnabled.ValueBool())
	}
	if !plan.IDPDynamicClientRegistrationAccessTokenTemplateContent.IsNull() && !plan.IDPDynamicClientRegistrationAccessTokenTemplateContent.IsUnknown() {
		createReq.IDPDynamicClientRegistrationAccessTokenTemplateContent = ptr(plan.IDPDynamicClientRegistrationAccessTokenTemplateContent.ValueString())
	}

	createResp, err := r.client.Environments.Create(ctx, createReq)
	if err != nil {
		resp.Diagnostics.AddError("Failed to create environment", err.Error())
		return
	}

	tflog.Info(ctx, "Created test environment")

	// Build the state
	plan = refreshFromEnvironment(createResp.Environment)
	plan.LastUpdated = types.StringValue(time.Now().Format(time.RFC850))

	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
}

func (r *environmentResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state environmentResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx = tflog.SetField(ctx, "project_slug", state.ProjectSlug.ValueString())
	ctx = tflog.SetField(ctx, "project_id", state.ProjectID.ValueString())
	ctx = tflog.SetField(ctx, "environment_slug", state.EnvironmentSlug.ValueString())
	tflog.Info(ctx, "Reading environment")

	getResp, err := r.client.Environments.Get(ctx, environments.GetRequest{
		ProjectSlug:     state.ProjectSlug.ValueString(),
		EnvironmentSlug: state.EnvironmentSlug.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError("Failed to get environment", err.Error())
		return
	}

	// Validate that this is a TEST environment
	if getResp.Environment.Type != environments.EnvironmentTypeTest {
		resp.Diagnostics.AddError(
			"Invalid environment type",
			fmt.Sprintf("This resource only supports TEST environments. The environment read has type: %s", getResp.Environment.Type),
		)
		return
	}

	tflog.Info(ctx, "Read environment")

	// Update the state
	state = refreshFromEnvironment(getResp.Environment)

	diags = resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}

func (r *environmentResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan environmentResourceModel
	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	var state environmentResourceModel
	diags = req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx = tflog.SetField(ctx, "project_slug", state.ProjectSlug.ValueString())
	ctx = tflog.SetField(ctx, "project_id", state.ProjectID.ValueString())
	ctx = tflog.SetField(ctx, "environment_slug", state.EnvironmentSlug.ValueString())
	tflog.Info(ctx, "Updating environment")

	updateReq := environments.UpdateRequest{
		ProjectSlug:     state.ProjectSlug.ValueString(),
		EnvironmentSlug: state.EnvironmentSlug.ValueString(),
	}

	if !plan.Name.Equal(state.Name) {
		updateReq.Name = ptr(plan.Name.ValueString())
	}
	if !plan.CrossOrgPasswordsEnabled.IsNull() && !plan.CrossOrgPasswordsEnabled.Equal(state.CrossOrgPasswordsEnabled) {
		updateReq.CrossOrgPasswordsEnabled = ptr(plan.CrossOrgPasswordsEnabled.ValueBool())
	}
	if !plan.UserImpersonationEnabled.IsNull() && !plan.UserImpersonationEnabled.Equal(state.UserImpersonationEnabled) {
		updateReq.UserImpersonationEnabled = ptr(plan.UserImpersonationEnabled.ValueBool())
	}
	if !plan.ZeroDowntimeSessionMigrationURL.IsNull() && !plan.ZeroDowntimeSessionMigrationURL.Equal(state.ZeroDowntimeSessionMigrationURL) {
		updateReq.ZeroDowntimeSessionMigrationURL = ptr(plan.ZeroDowntimeSessionMigrationURL.ValueString())
	}
	if !plan.UserLockSelfServeEnabled.IsNull() && !plan.UserLockSelfServeEnabled.Equal(state.UserLockSelfServeEnabled) {
		updateReq.UserLockSelfServeEnabled = ptr(plan.UserLockSelfServeEnabled.ValueBool())
	}
	if !plan.UserLockThreshold.IsNull() && !plan.UserLockThreshold.Equal(state.UserLockThreshold) {
		updateReq.UserLockThreshold = ptr(int(plan.UserLockThreshold.ValueInt32()))
	}
	if !plan.UserLockTTL.IsNull() && !plan.UserLockTTL.Equal(state.UserLockTTL) {
		updateReq.UserLockTTL = ptr(int(plan.UserLockTTL.ValueInt32()))
	}
	if !plan.IDPAuthorizationURL.IsNull() && !plan.IDPAuthorizationURL.Equal(state.IDPAuthorizationURL) {
		updateReq.IDPAuthorizationURL = ptr(plan.IDPAuthorizationURL.ValueString())
	}
	if !plan.IDPDynamicClientRegistrationEnabled.IsNull() && !plan.IDPDynamicClientRegistrationEnabled.Equal(state.IDPDynamicClientRegistrationEnabled) {
		updateReq.IDPDynamicClientRegistrationEnabled = ptr(plan.IDPDynamicClientRegistrationEnabled.ValueBool())
	}
	if !plan.IDPDynamicClientRegistrationAccessTokenTemplateContent.IsNull() && !plan.IDPDynamicClientRegistrationAccessTokenTemplateContent.Equal(state.IDPDynamicClientRegistrationAccessTokenTemplateContent) {
		updateReq.IDPDynamicClientRegistrationAccessTokenTemplateContent = ptr(plan.IDPDynamicClientRegistrationAccessTokenTemplateContent.ValueString())
	}

	updateResp, err := r.client.Environments.Update(ctx, updateReq)
	if err != nil {
		resp.Diagnostics.AddError("Failed to update environment", err.Error())
		return
	}

	tflog.Info(ctx, "Updated environment")

	// Update the state
	state = refreshFromEnvironment(updateResp.Environment)
	state.LastUpdated = types.StringValue(time.Now().Format(time.RFC850))

	diags = resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
}

func (r *environmentResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state environmentResourceModel
	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	ctx = tflog.SetField(ctx, "project_slug", state.ProjectSlug.ValueString())
	ctx = tflog.SetField(ctx, "project_id", state.ProjectID.ValueString())
	ctx = tflog.SetField(ctx, "environment_slug", state.EnvironmentSlug.ValueString())
	tflog.Info(ctx, "Deleting environment")

	_, err := r.client.Environments.Delete(ctx, environments.DeleteRequest{
		ProjectSlug:     state.ProjectSlug.ValueString(),
		EnvironmentSlug: state.EnvironmentSlug.ValueString(),
	})
	if err != nil {
		resp.Diagnostics.AddError("Failed to delete environment", err.Error())
		return
	}

	tflog.Info(ctx, "Deleted environment")
}

func (r *environmentResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	ctx = tflog.SetField(ctx, "import_id", req.ID)
	tflog.Info(ctx, "Importing environment")

	// Import ID format: project_slug.environment_slug
	parts := strings.Split(req.ID, ".")
	if len(parts) != 2 {
		resp.Diagnostics.AddError(
			"Invalid import ID format",
			fmt.Sprintf("Expected import ID format: project_slug.environment_slug, got: %s", req.ID),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("project_slug"), parts[0])...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("environment_slug"), parts[1])...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
}

// Helper function to refresh the environment model from API response.
func refreshFromEnvironment(env environments.Environment) environmentResourceModel {
	return environmentResourceModel{
		ID:                                  types.StringValue(fmt.Sprintf("%s.%s", env.ProjectSlug, env.EnvironmentSlug)),
		ProjectSlug:                         types.StringValue(env.ProjectSlug),
		ProjectID:                           types.StringValue(env.ProjectID),
		EnvironmentSlug:                     types.StringValue(env.EnvironmentSlug),
		Name:                                types.StringValue(env.Name),
		OAuthCallbackID:                     types.StringValue(env.OAuthCallbackID),
		CrossOrgPasswordsEnabled:            types.BoolValue(env.CrossOrgPasswordsEnabled),
		UserImpersonationEnabled:            types.BoolValue(env.UserImpersonationEnabled),
		ZeroDowntimeSessionMigrationURL:     types.StringValue(env.ZeroDowntimeSessionMigrationURL),
		UserLockSelfServeEnabled:            types.BoolValue(env.UserLockSelfServeEnabled),
		UserLockThreshold:                   types.Int32Value(int32(env.UserLockThreshold)),
		UserLockTTL:                         types.Int32Value(int32(env.UserLockTTL)),
		IDPAuthorizationURL:                 types.StringValue(env.IDPAuthorizationURL),
		IDPDynamicClientRegistrationEnabled: types.BoolValue(env.IDPDynamicClientRegistrationEnabled),
		IDPDynamicClientRegistrationAccessTokenTemplateContent: types.StringValue(env.IDPDynamicClientRegistrationAccessTokenTemplateContent),
		CreatedAt: types.StringValue(env.CreatedAt.Format(time.RFC3339)),
	}
}
